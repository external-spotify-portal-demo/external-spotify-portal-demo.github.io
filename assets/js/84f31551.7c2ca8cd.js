"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[796],{3905:(e,t,a)=>{a.d(t,{Zo:()=>d,kt:()=>f});var n=a(7294);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,o=function(e,t){if(null==e)return{};var a,n,o={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(o[a]=e[a]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var c=n.createContext({}),s=function(e){var t=n.useContext(c),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},d=function(e){var t=s(e.components);return n.createElement(c.Provider,{value:t},e.children)},h="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,o=e.mdxType,i=e.originalType,c=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),h=s(a),u=o,f=h["".concat(c,".").concat(u)]||h[u]||p[u]||i;return a?n.createElement(f,r(r({ref:t},d),{},{components:a})):n.createElement(f,r({ref:t},d))}));function f(e,t){var a=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=a.length,r=new Array(i);r[0]=u;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l[h]="string"==typeof e?e:o,r[1]=l;for(var s=2;s<i;s++)r[s]=a[s];return n.createElement.apply(null,r)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},3880:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>p,frontMatter:()=>i,metadata:()=>l,toc:()=>s});var n=a(7462),o=(a(7294),a(3905));const i={title:"Source Control Management",sidebar_position:1},r=void 0,l={unversionedId:"soundcheck/3p-integrations/scm",id:"soundcheck/3p-integrations/scm",title:"Source Control Management",description:"Source Control Management (SCM) integration for",source:"@site/docs/soundcheck/3p-integrations/scm.mdx",sourceDirName:"soundcheck/3p-integrations",slug:"/soundcheck/3p-integrations/scm",permalink:"/soundcheck/3p-integrations/scm",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/soundcheck/3p-integrations/scm.mdx",tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"Source Control Management",sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Third Party Integrations",permalink:"/category/third-party-integrations"},next:{title:"Github",permalink:"/soundcheck/3p-integrations/github"}},c={},s=[{value:"Prerequisites",id:"prerequisites",level:2},{value:"SCM Integrations - Connecting the SCM module to SCM providers",id:"scm-integrations---connecting-the-scm-module-to-scm-providers",level:3},{value:"Add the ScmFactCollector to Soundcheck",id:"add-the-scmfactcollector-to-soundcheck",level:3},{value:"Adding SCM Entities",id:"adding-scm-entities",level:3},{value:"Configuring the SCM Module",id:"configuring-the-scm-module",level:2},{value:"SCM Fact Extraction Configuration",id:"scm-fact-extraction-configuration",level:2},{value:"Contents",id:"contents",level:3},{value:"SCM Fact Collection Configuration Files",id:"scm-fact-collection-configuration-files",level:3},{value:"<code>frequency</code> Optional",id:"frequency-optional",level:4},{value:"<code>filter</code> Optional",id:"filter-optional",level:4},{value:"<code>cache</code> Optional",id:"cache-optional",level:4},{value:"<code>collects</code>",id:"collects",level:4},{value:"SCM Fact Extractors",id:"scm-fact-extractors",level:2},{value:"Common Fact Extractor Schema",id:"common-fact-extractor-schema",level:3},{value:"<code>factName</code>",id:"factname",level:4},{value:"<code>filter</code> Optional",id:"filter-optional-1",level:4},{value:"<code>cache</code> Optional",id:"cache-optional-1",level:4},{value:"<code>frequency</code> optional",id:"frequency-optional-1",level:4},{value:"<code>branch</code> optional",id:"branch-optional",level:4},{value:"Exists Fact Extractor",id:"exists-fact-extractor",level:3},{value:"<code>type</code>",id:"type",level:4},{value:"<code>data</code>",id:"data",level:4},{value:"Sample Exists Configuration",id:"sample-exists-configuration",level:4},{value:"Regex Fact Extractor",id:"regex-fact-extractor",level:3},{value:"True/False Mode",id:"truefalse-mode",level:6},{value:"Regex Capture Groups",id:"regex-capture-groups",level:6},{value:"Regex Fact Extractor Schema",id:"regex-fact-extractor-schema",level:4},{value:"<code>type</code>",id:"type-1",level:4},{value:"<code>path</code>",id:"path",level:4},{value:"<code>regex</code>",id:"regex",level:4},{value:"<code>data</code> Optional",id:"data-optional",level:4},{value:"Sample Regex Configuration",id:"sample-regex-configuration",level:4},{value:"JSON/YAML Fact Extractor",id:"jsonyaml-fact-extractor",level:3},{value:"JSON/YAML Fact Extractor Schema",id:"jsonyaml-fact-extractor-schema",level:4},{value:"<code>type</code>",id:"type-2",level:4},{value:"<code>path</code>",id:"path-1",level:4},{value:"<code>data</code>",id:"data-1",level:4},{value:"Sample json/yaml Configuration",id:"sample-jsonyaml-configuration",level:4}],d={toc:s},h="wrapper";function p(e){let{components:t,...a}=e;return(0,o.kt)(h,(0,n.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Source Control Management (SCM) integration for\n",(0,o.kt)("a",{parentName:"p",href:"https://backstage.spotify.com/plugins/soundcheck/"},"Soundcheck"),"."),(0,o.kt)("p",null,"The soundcheck-backend-module-scm plugin allows soundcheck to integrate with the following source\ncontrol management providers:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"azure"),(0,o.kt)("li",{parentName:"ul"},"bitbucketCloud"),(0,o.kt)("li",{parentName:"ul"},"bitbucketServer"),(0,o.kt)("li",{parentName:"ul"},"gerrit"),(0,o.kt)("li",{parentName:"ul"},"gitea"),(0,o.kt)("li",{parentName:"ul"},"github"),(0,o.kt)("li",{parentName:"ul"},"gitlab")),(0,o.kt)("h2",{id:"prerequisites"},"Prerequisites"),(0,o.kt)("h3",{id:"scm-integrations---connecting-the-scm-module-to-scm-providers"},"SCM Integrations - Connecting the SCM module to SCM providers"),(0,o.kt)("p",null,"To connect to external providers, an 'integration' must be provided in the main app-config.yaml file\nas follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},"integrations:\n  github:\n    - host: github.com\n      token: ${GITHUB_TOKEN}\n")),(0,o.kt)("p",null,"The above provides a github integration, with the host set as github.com. Authentication is provided\nvia a token issued from github.com for the repository to which you'd like to connect."),(0,o.kt)("p",null,"Full integration configuration details can be found\n",(0,o.kt)("a",{parentName:"p",href:"https://backstage.io/docs/integrations/github/locations"},"here"),"."),(0,o.kt)("h3",{id:"add-the-scmfactcollector-to-soundcheck"},"Add the ScmFactCollector to Soundcheck"),(0,o.kt)("p",null,"When creating the soundcheck-backend, add the ",(0,o.kt)("inlineCode",{parentName:"p"},"GitHubFactCollector"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"import { SoundcheckBuilder } from '@spotify/backstage-plugin-soundcheck-backend';\nimport { Router } from 'express';\nimport { PluginEnvironment } from '../types';\n\nexport default async function createPlugin(\n  env: PluginEnvironment,\n): Promise<Router> {\n  return SoundcheckBuilder.create({ ...env })\n    .addFactCollectors(\n      ScmFactCollector.create(env.config, env.logger, env.cache),\n    )\n    .build();\n}\n")),(0,o.kt)("h3",{id:"adding-scm-entities"},"Adding SCM Entities"),(0,o.kt)("p",null,"To use SCM integrations, an entity hosted by an SCM provider is needed.\nAs an example, an entity could be added to the catalog with a ",(0,o.kt)("inlineCode",{parentName:"p"},"type")," of 'url' and a ",(0,o.kt)("inlineCode",{parentName:"p"},"target")," that\ncorresponds to the entity's hosted location, like so:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},"catalog:\n  locations:\n    # Soundcheck external demo\n    - type: url # Denotes SCM entities.\n      target: https://github.com/your_repo/blob/main/all-components.yaml\n")),(0,o.kt)("p",null,"The configuration above adds a component hosted by github.com and configured by the target yaml\nfile."),(0,o.kt)("h2",{id:"configuring-the-scm-module"},"Configuring the SCM Module"),(0,o.kt)("p",null,"The facts to be collected by the SCM module must be defined in one or more yaml files, and then\nreferenced in the soundcheck configuration in the app-config.yaml file like so:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},"soundcheck:\n  collectors:\n    scm:\n      - $include: ./scm-fact-extraction-configurations.yaml\n      - $include: ./more-scm-fact-extraction-configurations.yaml\n      - $include: ./even-more-scm-fact-extraction-configurations.yaml\n")),(0,o.kt)("p",null,"With an SCM entity in your catalog, an SCM integration in the main app-config.yaml, and SCM\nconfiguration files added to the soundcheck.collectors.scm field also in the main app-config.yaml,\nyour Backstage instance is almost ready to extract facts from SCM providers."),(0,o.kt)("p",null,"The next section covers how to set up the fact extraction configuration files to extract facts from\nSCM."),(0,o.kt)("h2",{id:"scm-fact-extraction-configuration"},"SCM Fact Extraction Configuration"),(0,o.kt)("h3",{id:"contents"},"Contents"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#SCM-Fact-Collection-Configuration-Files"},"SCM Fact Collection Configuration Files")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"#SCM-Fact-Extractors"},"Types of SCM Fact Extractors"))),(0,o.kt)("h3",{id:"scm-fact-collection-configuration-files"},"SCM Fact Collection Configuration Files"),(0,o.kt)("p",null,"The SCM fact collection configuration yaml files have the following structure:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},"frequency:\n  cron: '0 * * * *' # Defines a schedule for when the facts defined in this file should be collected\n  # This is optional and if omitted, facts will only be collected on demand.\nfilter: # A filter specifying which entities to collect the specified facts for\n  kind: 'Component'\ncache: # Defines if the collected facts should be cached, and if so for how long\n  duration:\n    hours: 2\ncollects: # An array of fact extractor configuration describing how to collect SCM facts.\n  - SCM Fact Extractor Configuration One\n  - SCM Fact Extractor Configuration Two\n  - ...\n  - SCM Fact Extractor Configuration N\n")),(0,o.kt)("p",null,"Variables in this file are defined below:"),(0,o.kt)("h4",{id:"frequency-optional"},(0,o.kt)("inlineCode",{parentName:"h4"},"frequency")," ","[Optional]"),(0,o.kt)("p",null,"The frequency at which the collector should be executed. Possible values are either a cron expression ",(0,o.kt)("inlineCode",{parentName:"p"},"{ cron: ... }")," or ",(0,o.kt)("a",{parentName:"p",href:"https://backstage.io/docs/reference/backend-tasks.humanduration"},"HumanDuration"),".\nThis is the default frequency for each extractor."),(0,o.kt)("h4",{id:"filter-optional"},(0,o.kt)("inlineCode",{parentName:"h4"},"filter")," ","[Optional]"),(0,o.kt)("p",null,"A filter specifying which entities to collect the specified facts for. Matches the ",(0,o.kt)("a",{parentName:"p",href:"https://backstage.io/docs/reference/catalog-client.entityfilterquery"},"filter format")," used by the Catalog API.\nThis is the default filter for each extractor."),(0,o.kt)("h4",{id:"cache-optional"},(0,o.kt)("inlineCode",{parentName:"h4"},"cache")," ","[Optional]"),(0,o.kt)("p",null,"If the collected facts should be cached, and if so for how long. Possible values are either ",(0,o.kt)("inlineCode",{parentName:"p"},"true")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"false")," or a nested ",(0,o.kt)("inlineCode",{parentName:"p"},"{ duration:")," ",(0,o.kt)("a",{parentName:"p",href:"https://backstage.io/docs/reference/types.humanduration"},"HumanDuration")," ",(0,o.kt)("inlineCode",{parentName:"p"},"}")," field.\nThis is the default cache config for each extractor."),(0,o.kt)("h4",{id:"collects"},(0,o.kt)("inlineCode",{parentName:"h4"},"collects")),(0,o.kt)("p",null,"An array of SCM Fact Extractor configurations describing how to collect SCM facts. See the section\nbelow for details on configuring the extractors."),(0,o.kt)("h2",{id:"scm-fact-extractors"},"SCM Fact Extractors"),(0,o.kt)("p",null,"The exists, regex and json/yaml fact extractor configurations are described in detail below, but\nall extractors share a common base, so we first cover that base schema before going into the\ndetailed schemas of the individual fact collectors."),(0,o.kt)("h3",{id:"common-fact-extractor-schema"},"Common Fact Extractor Schema"),(0,o.kt)("p",null,"All SCM fact extractors share a common base schema, the variables for which are defined below:"),(0,o.kt)("h4",{id:"factname"},(0,o.kt)("inlineCode",{parentName:"h4"},"factName")),(0,o.kt)("p",null,"The name of the fact to be extracted."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Minimum length of 1"),(0,o.kt)("li",{parentName:"ul"},"Maximum length of 100"),(0,o.kt)("li",{parentName:"ul"},"Alphanumeric with single separator instances of periods, dashes, underscores, or forward slashes")),(0,o.kt)("h4",{id:"filter-optional-1"},(0,o.kt)("inlineCode",{parentName:"h4"},"filter")," ","[Optional]"),(0,o.kt)("p",null,"A filter specifying which entities to collect the specified facts for. Matches the ",(0,o.kt)("a",{parentName:"p",href:"https://backstage.io/docs/reference/catalog-client.entityfilterquery"},"filter format")," used by the Catalog API.\nIf provided it overrides the default filter provided at the top level. If not provided it defaults to the filter provided at the top level. If neither extractor's filter nor default filter is provided the fact will be collected for all entities."),(0,o.kt)("h4",{id:"cache-optional-1"},(0,o.kt)("inlineCode",{parentName:"h4"},"cache")," ","[Optional]"),(0,o.kt)("p",null,"If the collected facts should be cached, and if so for how long. Possible values are either ",(0,o.kt)("inlineCode",{parentName:"p"},"true")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"false")," or a nested ",(0,o.kt)("inlineCode",{parentName:"p"},"{ duration:")," ",(0,o.kt)("a",{parentName:"p",href:"https://backstage.io/docs/reference/types.humanduration"},"HumanDuration")," ",(0,o.kt)("inlineCode",{parentName:"p"},"}")," field.\nIf provided it overrides the default cache config provided at the top level. If not provided it defaults to the cache config provided at the top level. If neither extractor's cache nor default cache config is provided the fact will not be cached.\nExample:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},"cache:\n  duration:\n    hours: 24\n")),(0,o.kt)("h4",{id:"frequency-optional-1"},(0,o.kt)("inlineCode",{parentName:"h4"},"frequency")," ","[optional]"),(0,o.kt)("p",null,"The frequency at which the fact extraction should be executed. Possible values are either a cron expression ",(0,o.kt)("inlineCode",{parentName:"p"},"{ cron: ... }")," or ",(0,o.kt)("a",{parentName:"p",href:"https://backstage.io/docs/reference/backend-tasks.humanduration"},"HumanDuration"),".\nIf provided it overrides the default frequency provided at the top level. If not provided it defaults to the frequency provided at the top level. If neither extractor's frequency nor default frequency is provided the fact will only be collected on demand.\nExample:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},"frequency:\n  minutes: 10\n")),(0,o.kt)("h4",{id:"branch-optional"},(0,o.kt)("inlineCode",{parentName:"h4"},"branch")," ","[optional]"),(0,o.kt)("p",null,"The branch to extract the fact from. If not provided, defaults to the repository's default branch."),(0,o.kt)("h3",{id:"exists-fact-extractor"},"Exists Fact Extractor"),(0,o.kt)("p",null,"This extractor collects information on whether a given set of files exists in\nthe SCM provider. The extensions to the base schema are as follows:"),(0,o.kt)("h4",{id:"type"},(0,o.kt)("inlineCode",{parentName:"h4"},"type")),(0,o.kt)("p",null,"Must be exactly ",(0,o.kt)("inlineCode",{parentName:"p"},"exists"),", like so:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},"type: exists\n")),(0,o.kt)("h4",{id:"data"},(0,o.kt)("inlineCode",{parentName:"h4"},"data")),(0,o.kt)("p",null,"The data collected for this fact. This is an array consisting of two pairs of ",(0,o.kt)("inlineCode",{parentName:"p"},"name")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"path"),":"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"name"),": An identifier for the data element."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"path"),": The path to the file.\nBoth name and path are subject to the naming restrictions of ",(0,o.kt)("a",{parentName:"li",href:"#factname"},"factName"),".")),(0,o.kt)("h4",{id:"sample-exists-configuration"},"Sample Exists Configuration"),(0,o.kt)("p",null,"Here is a sample yaml configuration for a fact that gets information on the\nexistence of two files, 'README.md' and 'license.txt':"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},"collects:\n  - factName:\n      readme_and_catalog_info_files_exist_fact # This gives this fact an identifier which is\n      # used to refer to the fact in other\n      # configuration files.\n    type: exists # This identifies the type of fact to collect.\n    data: # This defines the data element which will be returned in the\n      # fact object when the fact is collected.\n      - name: readme_exists # Label for the data element.\n        path: /README.md # The file for which existence will be determined.\n      - name: catalog_info_exists # Label for the data element.\n        path: /catalog-info.yaml # The file for which existence will be determined.\n    filter: # A filter to narrow the applicability of this fact.\n      metadata.name:\n        soundcheck-external-demo # This filter makes this fact applicable only to the\n        # component with the given name, in this case\n        # 'soundcheck-external-demo'\n")),(0,o.kt)("p",null,"The checks that will compare the data collected by this fact to the expected outcomes is specified\nin the app-config.yaml file. Note that because the fact collects two data elements, there will be\ntwo checks to check the value of each data element; those checks would look like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},"soundcheck:\n  checks:\n    - id: has_readme_check # The name of the check\n      rule: # How to evaluate this check\n        factRef: scm:default/readme_and_catalog_info_files_exist_fact # The fact data to reference\n        path: $.readme_exists # The path to the field to analyze\n        operator: equal # Indicates the operation to apply\n        value: true # The desired value of the field indicated in path, above.\n    - id: has_catalog_info_file_check\n      rule:\n        factRef: scm:default/readme_and_catalog_info_files_exist_fact\n        path: $.catalog_info_exists\n        operator: equal\n        value: true\n")),(0,o.kt)("p",null,"Finally, these two checks need to be listed in a program level within soundcheck-programs.yaml:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},"- id: demo\n  name: Demo\n  ownerEntityRef: group:default/owning_group\n  description: >\n    Demonstration of Soundcheck Exists Fact Extractor\n  levels:\n    - ordinal: 1\n      name: First level\n      description: Checks leveraging Soundcheck's SCM Exists Fact Extractor\n      checks:\n        - id: has_catalog_info_file_check # The identifier for the check.\n          name: Has catalog-info.yaml # A human-readable name for this check\n          description:\n            > # The description to display on the Soundcheck page for this check.\n            Repositories should contain a catalog-info.yaml file.\n        - id: has_readme_check\n          name: Has README.md\n          description: |\n            Repositories should provide a README.md file at root.\n")),(0,o.kt)("h3",{id:"regex-fact-extractor"},"Regex Fact Extractor"),(0,o.kt)("p",null,"The Regex Fact Extractor collects information about the contents of a file. Two modes are supported:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"true/false"),(0,o.kt)("li",{parentName:"ul"},"named capture groups")),(0,o.kt)("h6",{id:"truefalse-mode"},"True/False Mode"),(0,o.kt)("p",null,"The true/false usage uses a regex expression to search for a match in a specified file. If a regex\nmatch is found, the resulting fact data will contain true for a field named 'matches', else the\n'matches' field will contain false."),(0,o.kt)("h6",{id:"regex-capture-groups"},"Regex Capture Groups"),(0,o.kt)("p",null,"Using named capture groups allows the extractor to associate capture groups within a regex\nto named values which allows checks to verify those captured values are correct."),(0,o.kt)("h4",{id:"regex-fact-extractor-schema"},"Regex Fact Extractor Schema"),(0,o.kt)("p",null,"The extension schema for Regex Fact Extractors is as follows:"),(0,o.kt)("h4",{id:"type-1"},(0,o.kt)("inlineCode",{parentName:"h4"},"type")),(0,o.kt)("p",null,"Must be exactly ",(0,o.kt)("inlineCode",{parentName:"p"},"regex"),", like so:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},"type: regex\n")),(0,o.kt)("h4",{id:"path"},(0,o.kt)("inlineCode",{parentName:"h4"},"path")),(0,o.kt)("p",null,"The path to the file to analyze."),(0,o.kt)("h4",{id:"regex"},(0,o.kt)("inlineCode",{parentName:"h4"},"regex")),(0,o.kt)("p",null,"A valid regex string. This string is used on the file to collect data elements or provide a true/\nfalse response corresponding to the regex finding a match in the file."),(0,o.kt)("h4",{id:"data-optional"},(0,o.kt)("inlineCode",{parentName:"h4"},"data")," ","[Optional]"),(0,o.kt)("p",null,"Defines the data to collect for this fact. This is an array consisting of two pairs of ",(0,o.kt)("inlineCode",{parentName:"p"},"name")," and\n",(0,o.kt)("inlineCode",{parentName:"p"},"type"),":"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"name"),": An identifier for the data element. Subject to the naming restrictions of\n",(0,o.kt)("a",{parentName:"li",href:"#factname"},"factName"),"."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"type"),": The expected type of data to be collected.")),(0,o.kt)("p",null,"Each pair defined in the data field ",(0,o.kt)("em",{parentName:"p"},"must")," correspond to a capture group in the given regex,\na mismatch between data element definition counts and regex capture groups is an error and the fact\ndata will not be collected."),(0,o.kt)("p",null,"If the data element is not present, the mode of the Regex Fact Extractor defaults to true/false."),(0,o.kt)("h4",{id:"sample-regex-configuration"},"Sample Regex Configuration"),(0,o.kt)("p",null,"The yaml below defines both modes of the Regex extractor, true/false and data collection.\nSample fact definitions are as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},"collects:\n  - factName: apache_license_fact # Name of the fact\n    type: regex # Type of the fact\n    path: /LICENSE.md # Path to the file whose contents will be searched\n    regex: .*Apache License.*Version 2\\.0.* # Regex to match.\n    # Note lack of any 'data:' object definition, this implies this regex is a true/false type.\n\n  - factName: api_version_fact\n    type: regex\n    path: /catalog-info.yaml\n    regex:\n      '^apiVersion: backstage.io/(.+)' # Note the capture group! Each capture group in a regex\n      # *must* correspond to a named data element, see below.\n    data: # Data describing each capture group\n      - name: captured_api_version # The name of the first capture group\n        type: string # The type of the first capture group.\n")),(0,o.kt)("p",null,"With fact collection specified, we now must define checks against the data that will be collected\nfor each fact. We define the checks in the app-config.yaml file. Sample checks that correspond to\nthe regex facts above are as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},"soundcheck:\n  checks:\n    - id: uses_recommended_license_check # ID for this check\n      rule: # How to evaluate this check\n        factRef: scm:default/apache_license_fact # The fact data to reference\n        path:\n          $.matches # The path to the field to analyze, note that this is always 'matches' for a\n          # true/false type regex.\n        operator: equal # Indicates the operation to apply\n        value:\n          true # The desired value of path field, above. True here indicates\n          # that, indeed, we want to have found the 2.0 apache license version in the\n          # given file.\n\n    - id: api_version_check\n      rule:\n        factRef: scm:default/api_version_fact\n        path:\n          $.captured_api_version # This path refers to the name given to the capture group in\n          # the fact definition.\n        operator: equal\n        value:\n          v1alpha1 # This is the value we expect to have captured via the regex for this\n          # capture group. This can be any string.\n")),(0,o.kt)("p",null,"Finally, the checks defined above must be present in the soundcheck-programs.yaml file under a level\nof a program. Such inclusion would look like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},'---\n- id: demo\n  name: Demo\n  ownerEntityRef: group:default/owning_group\n  description: >\n    Demonstration of Soundcheck Regex Fact Extractor\n  levels:\n    - ordinal: 1\n      name: First level\n      description: Checks leveraging Soundcheck\'s SCM Regex Fact Extractor\n      checks:\n        - id: uses_recommended_license_check # Check ID to include\n          name: Uses Apache License 2.0 # Human-readable name for this check.\n          description: |\n            Use of the Apache License 2.0 is required.\n        - id: api_version_check\n          name: Has correct API version\n          description: >\n            "Ensures that the component is using the correct api version, which is\n            v1alpha1".\n')),(0,o.kt)("h3",{id:"jsonyaml-fact-extractor"},"JSON/YAML Fact Extractor"),(0,o.kt)("p",null,"The final fact extractor type supported by the SCM module is the json/yaml fact extractor, which\nworks similar to the regex fact extractor in that it extracts json/yaml values from a file for use\nin checks."),(0,o.kt)("h4",{id:"jsonyaml-fact-extractor-schema"},"JSON/YAML Fact Extractor Schema"),(0,o.kt)("p",null,"The extensions to the base schema are as follows."),(0,o.kt)("h4",{id:"type-2"},(0,o.kt)("inlineCode",{parentName:"h4"},"type")),(0,o.kt)("p",null,"Must be one of ",(0,o.kt)("inlineCode",{parentName:"p"},"json")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"yaml"),", like so:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},"type: json\n")),(0,o.kt)("h4",{id:"path-1"},(0,o.kt)("inlineCode",{parentName:"h4"},"path")),(0,o.kt)("p",null,"The path to the file to analyze."),(0,o.kt)("h4",{id:"data-1"},(0,o.kt)("inlineCode",{parentName:"h4"},"data")),(0,o.kt)("p",null,"Defines the data to collect for this fact. This is an array of the following fields:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"name"),": An identifier for the data element.\nSubject to the naming restrictions of ",(0,o.kt)("a",{parentName:"li",href:"#factname"},"factName"),"."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"type"),": The expected type of data to be collected, either ",(0,o.kt)("inlineCode",{parentName:"li"},"array")," or a primitive type\n(",(0,o.kt)("inlineCode",{parentName:"li"},"string"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"int"),", etc.)"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"jsonPath"),": A period delimited path to the desired json/yaml element."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"items"),": A optional field with a single subtype of ",(0,o.kt)("inlineCode",{parentName:"li"},"type"),". If included, the data returned by the\nfact will be an array of all matching elements of the specified type. If 'items' is omitted, the\nreturned value will be a single element.")),(0,o.kt)("h4",{id:"sample-jsonyaml-configuration"},"Sample json/yaml Configuration"),(0,o.kt)("p",null,"The yaml below defines both types of collection by the json/yaml extractor: single element and array\ncapture.\nSample fact definitions are as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},"collects:\n  - factName: entity_metadata_fact # Name of the fact\n    type: json # Type of the fact\n    path: /catalog-info.yaml # Path to the file whose contents will be searched\n    data: # Data describing the file contents collected at each jsonPath\n      - name: tags # Name for this entry in the data element.\n        jsonPath: metadata.tags # Path from which to pull data from the file.\n        type: array # Type of element, array or primitive.\n        items: # For the array type, this items specification and the type of the items is required.\n          type: string\n      - name: pager_duty_integration_key\n        jsonPath: metadata.annotations.pagerduty_integration-key\n        type: string # For non-array captures, just the type of the data is required.\n")),(0,o.kt)("p",null,"The above data specifications are the two types supported by this extractor, corresponding to arrays\nand strings, respectively. In the above, metadata.tags will be extracted into an array named 'tags'\nof type String, and metadata.annotations.pagerduty_integration-key will be extracted into a\nvariable called pager_duty_integration_key of type string."),(0,o.kt)("p",null,"The checks for the fact data extracted based on the fact specification above could be as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},"soundcheck:\n  checks:\n    - id: entity_metadata_tags_check # ID of this check\n      rule: # How to evaluate this check\n        factRef: scm:default/entity_metadata_fact # The fact data to reference\n        path: $.tags # The path to the data in the collected fact's 'data' element\n        operator: notEqual # The operation to apply\n        value: undefined # The value to compare with the extracted value.\n    - id: entity_metadata_key_check\n      rule:\n        factRef: scm:default/entity_metadata_fact\n        path: $.pager_duty_integration_key\n        operator: equal\n        value: 12345\n")),(0,o.kt)("p",null,"Above, we define two checks. The first ensures that the tags array is not undefined in the file,\nthat is, that there are tags present. The second check ensures that the pager duty key is in the\nfile and that it is equal to the given value."),(0,o.kt)("p",null,"Finally, we add these checks to the soundcheck-program.yaml file under an appropriate ordinal. As\nan example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},"- id: demo\n  name: Demo\n  ownerEntityRef: group:default/owning_group\n  description: >\n    Demonstration of Soundcheck Regex Fact Extractor\n  levels:\n    - ordinal: 1\n      name: First level\n      description: Checks leveraging Soundcheck's SCM Regex Fact Extractor\n      checks:\n        - id: entity_metadata_tags_check\n          name: Entity Metadata Tags Check\n          description: Check that metadata tags are present.\n\n        - id: entity_metadata_key_check\n          name: Entity Metadata Key Check\n          description: Check that the pager duty key is correct.\n")),(0,o.kt)("p",null,"Adding the above to the soundcheck-programs.yaml would make the checks defined in this section\nnecessary for whichever program and level to which they were added to be considered passing."))}p.isMDXComponent=!0}}]);